Efficiency review for Program # 1 by Tejas Menon, CS163, edited last on 4/17.

1) Evaluation of the data structure used currently

The ADT I implemented for this first program worked with an LLL of room nodes, with each one containing its own LLL of message nodes. The benefits of this procedure were that any additions or removals to this 'relatively' positioned list were extremely efficient as I only needed to affect a single node without shifting any data. Additionally, since I only added rooms to the beginning of the list (insertion), the process was a 'constant time' function since it didn't matter how big the list was. The messages added to rooms were also sorted by time, and therefore meant that any time related removals or retrievals were more efficient and less laborsome to perform. However, implementing the participants of a room as a dynamically allocated character array meant that any removals or additions of participants would a difficult task since a new array would have had to be allocated (and the data copied over) for each room. An alternative would have been to have a linear linked list of participants or for large quantities of data, an LLL holding character pointers to arrays of participants.

A modular benefit I had to my data structure was having a destructor function for each node that simply called itself and deallocated the next pointer when it went out of scope. This universality meant that I could simply call the 'delete' function in the parent destructor in CS_Chat and have the entirety of the data structure deallocated without having to write specific destructor functions. Also, this meant that the client could simply request a 'delete' on any structure made to pass to functions, without having to worry about deallocating them individually. Using a modular design for my ADT functions too, with a public wrapper/primary function calling the private recursive/secondary function meant that I could write much smaller, better readable code, and also cater to many more possibilities of success and failure returns. 

2) Drawbacks of my current data structure

My utilization of data structures that encompassed the function of 'nodes' (by having pointers to parts of the data structure) means that the expansion of this ADT to include more functions would be difficult, in the sense that if there existed a function to which the client needed to pass or retrieve a message or room, he/she would have needed to be privy to the address of parts of the data structure, which would then have violated the meaning of an ADT. To preclude this necessity for a future program, a solution could be to create two mode structures node1 and node2 (one for the rooms and another for the messages), and move any 'data connecting' pointers to these nodes and simpy have the room and message structures hold just its data and become instances in the aforementioned nodes. 

Had I recieved more time to solve the problem and attacked it more modularly rather than worry about the workings of the ADT in parallel with the client, one potentially better solution - having three classes instead of a single one, could have been utilized instead. Three classes, one for message, room and the original CS_Chat could have been used and each class work with separate member functions that could be called from another object. This would have meant that the lower level classes would have been solely responsible for the the basic 'deep copying' and comparing functions while the 'list' classes (room and CS_Chat) would have been performing the more higher level, structural functions. All in all, such a modular implementation would have produced shorter, more readable and better maintainable code and allowed for better options for expansion. 