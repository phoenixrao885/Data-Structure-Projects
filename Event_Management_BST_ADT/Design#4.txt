Design write-up for Program # 4 by Tejas Menon, CS163, edited on 5/26.

1) Structural layout of my ADT:

For Program 4, the entirety of the surrounding aspects of my ADT - for example the client program, the event and keyword classes - will retain most of its structural implementation from Program # 3 since almost all of the functions that is to be called on the ADT is the same, while the underlying ADT will observe significant change. For one, I will change the node struct from Program#3 to include both right and left pointers and in addition store the event instance within the node rather than use a pointer pointing to it. This can be done without risking event duplicates since each event will be added into the ADT only once, regardless of the number of keywords it contains. This also means that the destructer function this time can be made recursive unlike in Program#3 where we had to take care of the case where more than one node pointed to the same event instance. The destructor for the BST class can simply use any of the three 'per-order, post-order or in-order' types of traversals to deallocate the BST since the order that we visit our nodes does not matter as long as we visit each and every node. 

2) The 'event' class:

This class will contain dynamically allocated character pointers for the title, location and the description of the event and for the date and time, a time_t timestamp can be used, calculated in the client file using values from the date and time to produce a number that is the 'seconds from epoch' or the 'seconds after the year 1900'. This will allow easy and streamlined storage of the time as a numeric value that can be accessible in whatever format determined by the client. Another data member for this class will be the dynamically allocated array of 'keywords' and an integer representing the number of keywords in that array. 

The functions on this class will include an add function, taking as arguments the title, location, description and the time_t timestamp, to perform a deep copy of the data to its pointers. This function can be called from the client every time a line from the data file is processed or whenever the user wants input of another event into the data structure.
Another function required for this class will be the copy(const event &) function that will make a deep copy of the values in the argument to its arguments. This function can be utilized specifically within the hashtable class to copy an event into the hashtable. Apart from these primary functions, few utility functions for an event can be the getTitle() function used to return the ASCII 'value' of the characters for comparison during removals and the getKeyword(keyword []) function that will perform a deep copy into the supplied argument all the keywords (this function will be useful to compare between keywords for event removal). Note that the calling routine will be privy to the number of keywords for an event as this data member will be present within the public section of the class. 

3) The 'BST' class:

This class will perfrom the primary job of storing and retrieving events and will be constructed as a binary search tree with a root pointer that points to an instance of the node aforementioned. Most of the functions can be made recursive except specific parts of the functions such as for the removal of an event with a specific title or the removal of an event with the mentioned keyword. 

The add_event function within the BST will take as argument an 'event' and depending on the ASCII value of its title (supplied by the getTitle() function), I can call the same function recursively using either the root->left or root->right. Finally as a base case, when I reach a 'root' that is NULL, since I have passed by reference, I can create a new node here and deep copy the event to this new node. A general removal function can be used to assist for operations of both the remove_events_with_(char title []) and also the remove_events_with(char keyword[]). How this can be achieved is by having the remove keyword function call the remove_events_with(char title[]) for all nodes that require removal. This will very much require the remove keyword function to retain the next (left and right) pointers prior to calling the remove_with_title() function. This two way optimisation will allow for much more concise code and a modular way of implementaion.

The retrieve function can simply use the search algorithm aforementioned and copy into the argument event all the details of the event that has a matching title. The display_all() can be implemented using in-order traversal algorithm in a recursive function to access all events alphabetically and display them one after the other. 