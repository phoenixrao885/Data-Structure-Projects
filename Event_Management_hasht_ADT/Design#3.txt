Design write-up for Program # 3 by Tejas Menon, CS163, edited on 5/12.

1) Structural layout of my ADT:

For Program 3, I will implement two classes; the 'event' class and the 'hashtable' class, instances of which will be created in the client program, and will be used by the program to read in first the information from the external data file into separate 'event' instances, and after which user interaction in a menu based system will allow for selective testing of all the functions within the hashtable. Additionally, I will also include a node structure which will contain a pointer to an event and a pointer to the next node, and also a recursive deallocator function that will 'delete next' if it isn't a zero equivalent value. Each event will also require an array of keywords and therefore I will also include a 'keyword' structure that will contain a dynamically allocated character array. 

2) The 'event' class:

This class will contain dynamically allocated character pointers for the title, location and the description of the event and for the date and time, a time_t timestamp can be used, calculated in the client file using values from the date and time to produce a number that is the 'seconds from epoch' or the 'seconds after the year 1900'. This will allow comparisons on the time (for the removal function) easy to perform as they will be numeric values. Another data member for this class will be the dynamically allocated array of 'keywords' and an integer representing the number of keywords in that array. 

The functions on this class will include an add function, taking as arguments the title, location, description and the time_t timestamp, to perform a deep copy of the data to its pointers. This function can be called from the client every time a line from the data file is processed or whenever the user wants input of another event into the data structure.
Another function required for this class will be the copy(const event &) function that will make a deep copy of the values in the argument to its arguments. This function can be utilized specifically within the hashtable class to copy an event into the hashtable. Apart from these primary functions, few utility functions for an event can be the getTime() function used to return the timestamp value for comparison during removals and the getKeyword(keyword []) function that will perform a deep copy into the supplied argument all the keywords. Note that the calling routine will be privy to the number of keywords for an event as this data member will be present within the public section of the class. 

3) The 'hashtable' class:

This class will perfrom the primary job of storing and retrieving events and will be constructed as a node* array - an array of node pointers - with each 'head' pointing to its own linear linked list of events. A prime number between 200-300 can be used as the size of this array that will ensure any 'mod' operations does not re-map hash function residuals to multiples of any index size and therefore maintain an even distribution. As data members, this hashtable will include just the node** pointer 'hash' that will be dynamically allocated the array of node pointers in the constructor. Within the constructor, a for loop can be implemented to set every node* to NULL prior to calling any functions. This will ensure any invalid pointer addresses are not dereferenced mistakenly.

The add_event function within the hashtable will take as argument an 'event' and will implement a for loop for each keyword for the event (procured using the getKeyword() function) and will pass this value to the secondary 'getHash' function that will return the (sumofkeywordchars()*productofkeywordchars()) % array_size) to the calling routine. This position in the array can be deferenced and a new node inserted at the beginning of the chain after confirming that there doesn't exist a duplicate event within the same chain. (The same event can be duplicated for different indexes in the array (due to different keywords) but the same event must not be added to the same chain). Next, this function can use the SAME new event address for a particular keyword to be connected to by all duplicate events in other chains. In this process, the total memory allocation for each event will be limited to one regardless of the number of keywords. However, this will also mean that the destructor will need to deallocate a node for a particular event only once to avoid segmentation errors. This can be achieved within the destructor by accessing the first node of each index, extracting its keywords and finding its corresponding hash indexes, and then deallocating the first node at each of these indexes, noting that only once will all the events for each index be deallocated, as deallocation will occur in the reverse order to insertion. The remove_before(time_t timestamp) can also utilize a similar strategy, where each event that requires removal can be acquired of its keywords, and the removal process can occur at each of these indexes. In theory, the destructor should function simply by calling the remove_before() function and passing it a very large timestamp (a few years into the future) and then of course performing a delete[]hashtable operation. 

The retrieve and display functions can use a similar strategy and simply find hash indexes of the keyword to be found and pass into the argument (for the retrieve function) or display (for the display function) all the events at this index if they contain a keyword that corresponds to the value to be found. (Note that there can theoretically be different keywords mapped to the same index). The retrieve function must also only allow insertions into its array of retrievals until MAX array size and disregard all other subsequent events in this chain. 

For the display_all function, a recursive secondary function can be used to display an LLL for each 'head' passed in by the wrapper function.  