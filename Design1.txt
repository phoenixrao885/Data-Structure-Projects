Design write-up for Program # 1 by Tejas Menon, CS163, edited on 4/11.

1) Structural layout of my ADT:

My ADT CS_Chat, will use public structures 'room', 'person' and 'message' declared prior to the class and execute on instances of them, member functions (wrappers) called from the public section of the class. These functions will relay necessary data and the head/tail pointer pointing to the first 'room' (or NULL) to recursive functions situated in the private section of CS_Chat. As per my initial conceptions, I believe most functions I write will require such a wrapper. 

Additionally, another aspect of my program I'm deciding would be recursive would be the deallocation operation invoked when the CS_Chat class destructor is run, for which I will require a destructor function for each structure 'room', 'person' and 'message'. For each of these destructors, I will first deallocate all pointers pointing to dynamic memory and then proceed to the next 'subproblem' by deallocating the 'next' pointer pointing to another instance of the same structure (if it isn't NULL). By this 'chain reaction' I will proceed to deallocate all dynamic memory present in each instance of all structures simply by requesting a 'delete head' operation in the CS_Chat class destructor.

a) The 'person' structure:

This structure will store two pointers to the username and email of a participant in a particular chat room, both of which will be allocated in the client program in an array of such 'person' structures (determined however by the client) and the ADT function (I will articulate ahead) will only recieve (as an argument) a pointer to the first element of this 'person' array in the event a new room needs to be added. As aformentioned, each instance of this person structure will deallocate the 'username' and 'email' pointers before being deleted. As a result, when the 'person * list' array is deallocated (delete [] list), every 'person' structure in that array will run its destructor prior to being deallocated.

b) The 'message' structure:

This structure will store the 'message data', the 'time_t timestamp' and a pointer to the next message in the linear linked list. For manipulating and using times, my program will utilize functions in an additional library 'ctime' included at the beginning of the header file (of which time_t is a data structure- fundamentally a signed integer). This message structure also will utilize the recursive deallocater mentioned before: deallocating 'message data' and the next pointer (if it isn't NULL). 

c) The 'room' structure:

This structure will store several details and point to instances of the structures aformentioned, namely the next room, a head pointer to its LLL of messages, a tail pointer to the end of this LLL, a 'person' pointer to an array of persons, the 'room name', 'number of people' and 'description'. Each of these data members will also require deallocation in a similar fashion as above in the destructor, deallocating its sequence of messages prior to the next room. 

2) The ADT Functions:

For the sake of comprehension, I will collapse the explanation of two functions performing the same job under the same heading, mentioning whenever the primary of those functions calls its secondary.

a) The insertroom function:

This function out of all, will be the only one without a pair, since its requirement doesn't mandate traversal as I will be inserting at the beginning of the LLL of rooms (or the first one). It will return a boolean value to the calling routine indicating the success of the inserting process. The only exceptions to a successful insertion would be if any of its pointer arguments - the 'room name', the 'description' or the 'list of persons' points to a NULL value or if any of the 'person' structures in the array contains a username or email pointing to a NULL value. In all such cases a zero equivalent value will be returned. An assumption made here is that the number of people (corresponding to the array size of the 'person list') sent in as an argument is accurate, the confirming of which would be a laborious task and therefore omitted, since sizeof(array)/array[i] would need to be performed before the array is passed into the function and it becomes a pointer, an operation that would be rendered meaningless since it would need to be performed in the client program.

To insert, this function will hold head's value (a private pointer in CS_Chat) and then add a new room to head, making 'head->next' pointer the 'hold' value. If tail is found to be NULL at this point, it will also be made to head's value. After this, all of the new room's variables will be initialized to a copy value of the arguments and a complete copy of all structures of the 'person list' will be created, and 'head->list' will be made to point to this new 'person' array, ensuring therefore that all memory remains separate between the client and the ADT, freeing the client to perform any operations to their arguments without affecting the ADT's data structure after the function call. 

b) The appendmessage pair of functions:

This function will add a message to the end of a message list (or be the first one) present in a specified chat room and will return a boolean success or failure value depending on whether the room specified by the client was present in the LLL or not. The primary function will simply call its recursive secondary, passing as argument the head pointer pointing to the first room, the content of the message and the room name to be appending this message into. This secondary boolean function will return zero in case of head being NULL (no rooms exist or if the recursive call continues until the end of the list (no match found)). If a match is found between the client inputted room_name and head->name, then a room will be appended to the end of that message list by using that room's 'tail' if it isn't NULL (therefore the message list wasn't empty). In the exception that the message list is empty, a new message will be appended to the head->head pointer and the head->tail pointer will be updated to this new last 'message'. In all other cases, head->tail->next will point to a new message and head->tail will point to this new allocation. 

After these initially differing operations for each case, all other operations will simply copy function arguments to the contents of this new 'message' allocation, generating a timestamp using the time() function from <ctime> and storing this value as a time_t type in the message node. 

c) The displayRoom pair of functions:

This function will display all the messages in a specified chat room, utilizing the primary function to traverse through the LLL of rooms and the recursive secondary to display all the messages and its corresponding timestamp. The cases where a display failure would be returned would be if any of the function arguments are NULL, if there was no matching room in the LLL or if there weren't any messages present in a particular room. To facilitate these operations, I will need to iteratively traverse in the primary function, evaluating with each iteration whether there is a match between the client inputted room and current->name and if there is one, call the secondary displayRoom passing it current->head (The pointer to the first 'message'). This secondary function must return a boolean value of whether it could display anything and the primary storing this boolean value in a variable to return to the client. In all cases, memory between the client and the ADT will remain separate as there isn't any new memory being allocated or returned. Also, to display the timestamp as a readable string rather than the 'seconds from epoch' stored in the time_t type, I can use the ctime(time_t *) function that takes in a pointer to a time_t and returns character output. 

d) The displayMessage pair of functions:

As before, this function will also use the primary function to traverse to each chat room and pass to the secondary, its message * head pointer, and the secondary function will evaluate whether the given keyword was present within its LLL of messages. To do the same, the secondary will utilize the strstr(const char *,const char *) function from the <cstring> library which takes in two character pointer arguments and determines if the second argument is wholly present within any portion of the first, returning a pointer to the first instance of such a match or a NULL pointer if not. My secondary function could utilize strstr() and determine if a NULL is being returned and if not, display the current head->message_data and its timestamp ctime(&(head->timestamp)). For each match found in this recursive secondary function, I can return the function call and add 1, therefore returning eventually a non-zero value if any one message was displayed successfully. 

e) The displayUsrGroup pair of functions:

This function will take as argument the username to find a match for from the client program and display all group names where the username participates. A zero equivalent value will be returned if the pointer to the first room is NULL, if the username inputted participated in no rooms or if the username pointer was simply NULL. To acheive this result, the primary function can be used as a wrapper to call its recursive secondary and pass it the username_to_check and the pointer to the first room. After this, a for loop can be run with each individual room checking if the inputted username matches the room's name. The for loop can be run for head->people iterations, a value that was initially stored when the room was created. If a match was found, a similar process as the displayMessage function can be implemented, where the function call plus 1 can be returned, therefore meaning that if there is a match for any single stack frame, a non-zero value will be returned to the initial function call. As before, I believe this function cannot possibly violate any of the ADT fundamentals since there is no memory being created or destroyed or returned to the client program. 

f) The removeMessageBefore pair of functions:

This function will use an intital time_t timestamp passed in and remove all messages that contains a timestamp smaller (earlier) in value to it, returning a failure if there existed no rooms, no messages for all rooms or if no messages existed before the timestamp argument for any room. Also, since messages in any chat room are sorted in order of lateness, with the latest message appended at the end, this must mean that if during traversal we encounter a single timestamp larger than (or same as) our argument, all others in succession to it will definitely be larger than the one we stopped at. Using this understanding, we can say that if we set our secondary function to return a pointer pointing to the address of the first message that contained a timestamp larger than (or same as) our argument - with the secondary function also making the message prior to that point to a NULL next message- we can simply execute a delete (current->head) operation in the primary function and allow the destructors in each of those messages to deallocate all memory until the NULL we just fashioned, and simply then set our current->head to the return address of the secondary function. Exceptions to this will evidently be if there existed no messages at all or if no messages required deletion, in which case current->head can simply be left unscathed, and the delete operation never executed. Another notable case to highlight would be if all messages were needing to be removed, in which case the secondary function would return NULL and the CS_Chat tail would require updation. 

