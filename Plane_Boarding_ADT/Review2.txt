Efficiency review for Program # 2 by Tejas Menon, CS163, edited last on 5/3.

1) Evaluation of the data structure used currently

Even though the ADT implemented for this program was efficient to a certain degree- mainly due to the use of a stack to represent sides of a plane- I thought the data structure used for queuing passengers seemed extremely inefficient to perform sorting operations on, simply due to restricted access of the data strucure- something I will expand on in the next section. Apart from that singlemost crucial caveat, the use of a circular linked list for the queues allowed for short and concise code that was constant time (since enqueueing and dequeueing were operations on extremeties of the data structure that didn't require traversal), and also allowed for operations on the queue to remain intuitive to the client, in the sense 'First in First out' closely mimicked an actual preboarding and boarding scenario. The same can also be said about the linked list of array structure used for the stack, where any operations on adding or disembarking passengers from the plane was of 'direct access' pace, and placing passengers on different rows of the structure intuitively meant more nodes were to be allocated. In essence, the use of a CLL and LLL of arrays with a queue and stack meant operations were more manageable and maintainable, simply because the physical structure of a queue and a plane closely matched our data structure. 

Another aspect of my program that allowed for greater maintainablity was I thought my use of 5 classes that performed their own jobs autonomously and therefore made higher level objects and functions contain less repetitive code. This also I thought allowed for the program to be rigorously testable and improved modularity while allowing code to be produced for each class that served only its purpose, without worrying about its usage in the grand scheme of the program. This provided 'mental boundaries' for me that kept my code on track, and additionally allowed for incremental development and testing without the use of very long unreadable functions. Also implementing recursive deallocation for all my data structures and objects meant that creating locals within functions didn't require deallocation or deletion, and instead they functioned simply as another data type available for multiple calls and reuse. 

2) Drawbacks of my current data structure

One of the main drawbacks with the use of a queue for the purpose of sorting was that data within the queue was available only one node deep, which in essence meant that enqueueing and dequeueing were needed to be performed multiple times for each passenger, a process that would have become unreasonably time consuming for very large queues. Additionally, the use of a circular linked list did not provide additional benefits that were proportional to the extra code used for maintaining them, which was a slight overhead. 

An alternative that could have been proposed was to have a doubly linked list data structure for our preboard and board queues that allows for traversal and comparison, and complex algorithms for sorting could have been implemented alongside. The usage of previous and next pointers would have allowed for backward traversal for our sorting algorithm, which would have definitely improved runtime performance from what stands currently. 