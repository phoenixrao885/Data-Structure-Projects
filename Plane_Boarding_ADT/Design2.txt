Design write-up for Program # 2 by Tejas Menon, CS163, edited on 4/26.

1) Structural layout of my ADT:

My ADT will incorporate 4 classes, the base data type 'passenger', a 'queue' formed by a circular linear linked list, a 'stack' that is a linear linked list of 'passenger' arrays and the highest level class 'plane', which will include as private members, two instances of a queue- the 'preboard' and 'board' queues- and two stacks- representative of the two sides of a plane. The client will interact with the 'plane' class, which will call the lower level class functions as required, and therefore maintain uncorrupted instances of the data structures shielded from the client. Essentially, the 'plane' class will be the only 'specialized' class representative of airplane boarding operations while the other classes will perform fundamental operations to add, remove, peek or display data requested from 'plane' functions.

Two additional structures to connect data will be the 's_node' and the 'q_node', the 'q(ueue)_node' collecting together a 'passenger' instance and its next pointer, while the 's(tack)_node' a pointer to a 'passenger' array and its next pointer. Each of these structures will also implement destructor functions that will deallocate its dynamic memory and its 'next' pointer, in the event it is a non-NULL value. 

a) The 'passenger' class:

The fundamental data type 'passenger' will store a passenger's name as a character pointer, their row number as an integer and a character denoting their seat- a value between 'A' to 'Z'- the integrity of which will be confirmed by functions in the 'plane' class prior to enqueueing into 'preboard'. Within the public section, the 'passenger' class will implement functions to add a passenger, taking as argument their name, row number and seat, returning a boolean value depending on whether the three arguments are non-zero or not. It will also implement a copy function, taking in an instance of 'passenger' and deep copying it into its own data members to return a boolean if the copy was successful. Other functions to retrieve information from a passenger instance will include the 'getSeat' and the 'getPos' function, each of which will pass in integer and character values to be modified to the values contained in that instance. Another function present in 'passenger' would be the display function that will output all its contents if they are non-zero values.

For deallocation, a 'passenger' instance would solely need to release its 'name' dynamic memory, an operation that can be performed in the destructor.


b) The 'queue' class:

This class will manage a circular linear linked list of 'q_nodes', holding as private variables a rear pointer pointing to the most recently added q_node, an integer denoting the maximum number of passengers that can be added into the data structure and the count, an integer denoting the total number of passengers enqueued. The maximum passenger integer variable can be initialized in the parameterized constructor to a value twice the product of the number of seats in half a row and the total number of rows. The reason for passing in from the client the number of seats in half a row is so that a row can always be maintained to have an even number of seats and both sides of the aisle remains identical. 

The functions to modify a queue that can be implemented would be the enqueue function, taking as argument an instance of passenger and also a boolean 'sort_check', a binary value depending on which the enqueue function can determine if the 'sorting' algorithm applies to the current passenger being enqueued or not. If applicable, the sorting algorithm can simply peek to the earlier passenger in the queue and determine if its 'boarding position' is smaller than the position of the current passenger being added, proceeding only if this logical comparison is true. Another function to modify the data structure can be the dequeue function, passing in a passenger instance to be filled in by the passenger data from the removed q_node. Each of these functions can be restricted to enqueue or dequeue depending on whether count>max or !rear. Additionally, another function to implement in 'queue' would be the display function that will temporarily set rear->next to NULL and traverse from the front of the queue until the rear stopping naturally when !current. The destructor of the queue can simply hold the value of rear->next and then set rear->next to NULL (if rear isn't already NULL), and then execute the delete operation on the held q_node which will kickstart the deallocation process since the destructor within all subsequent q_nodes would be invoked. 

c) The 'stack' class:

This class will manage a LLL of 's_nodes', inputting initially into its parameterized constructor the number of rows in the plane and the number of seats in a 'halfrow' for the same reasons aforementioned. The max seats on a stack can be assigned to the product of the total rows and the halfrow to a value half the total number of seats on a plane. Functions to modify the stack can include the push and pop functions, each of them taking in an instance of 'passenger' and performing either a deep copy to store within the data structure or within the argument prior to removal. For each of these, the copy function from 'passenger' can be utilized for conciseness. Other functions to implement in the stack would be the peek and display functions that will as before either deep copy the stack at top's index into the argument or iterate completely through the stack using the display function for a 'passenger'. The displaying can be performed in reverse order in a 'for' loop going from index (halfrow_size-1) to index zero since additions are made in increasing order for top and therefore displaying must be made in decreasing order for ease of comprehension and debugging. The destructor function in the class can simply request a delete operation on head (if it isn't NULL) and since all s_nodes subsequent contain destructor functions, they can automatically be deallocated in this 'recursive' fashion. 

d) The 'plane' class:

This class will be the primary mode of interaction between the client and the ADT, and will request the functions outlined above on its private data members from different functions. A function in this class will also be responsible for assigning the boarding position for each passenger prior to boarding. Its private data members will include the 'preboard' and 'board' queues, the 'rightwing' and 'leftwing' stacks and the integers maxSeats, maxRows and halfrow. The objects with parameterized constructors can be initialized by 'delegation' in the plane's constructor to their halfrow and max values. The functions to be requested from the client can include the add_to_preboard(passenger &), move_to_board(), seat_in_plane(), disembark(passenger &), display_preboard(), display_board() and display_plane(). The add_to_preboard function can calculate a passenger's boarding position using the getSeat function for a passenger assigning it the value halfrow*2*(maxRows - passenger's row number)+(toupper(passenger's seat char) - 'A'). This operation will assign a passenger a boarding value representative of their 'index' starting from the back of the plane allowing passengers boarding closer to the back to have a smaller 'index'. After determining this value, the passenger can be enqueued into the preboard queue irrespective of his/her boarding position. Next, the move_to_board function can dequeue passengers from the preboard queue and enqueue them back for (queue_size) number of times, stopping when the smallest value from the queue is reached and enqueue this passenger into the 'board' queue. This proceess can be repeated for (queue_size) number of times, each time the preboard queue becoming one smaller than the last iteration. This would result in a sorted 'board' queue. After this, the seat_in_plane function can be used to take passengers from the board queue and add them to the leftwing and rightwing stack depending on whether their boarding position is even or odd. (Since the assignment specifies that the seats closer to the windows must board first on either side of the aisle). For empty seats between passengers, an empty 'temp' passenger can be inputted into the stack (boarding number of last passenger - boarding number of next passenger) number of times. We can expect the copy operation to fail in each of these 'pushes' but the data structure can still be expected to increase in size as 'top' cyclically increases. The rest of the functions can simply be used to call the corresponding display and disembark operations in the stacks or queues passing these copied values back to the client.


